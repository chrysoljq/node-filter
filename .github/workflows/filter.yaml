name: Daily Node Filter

on:
  schedule:
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      mode:
        description: '检测模式'
        required: false
        type: choice
        default: 'precise'
        options:
          - precise
          - fast

env:
  PYTHON_VERSION: '3.12'
  GLOBAL_UA: 'clash-verge/2.4.5'

# Secrets 需要设置:
#   WORKER_URL       — Worker 地址 (https://sub-worker.xxx.workers.dev)
#   WORKER_AUTH_TOKEN — 管理 API 令牌
#   WORKER_SUB_TOKEN — 订阅获取令牌 (可选，仅备用直接拉取时用)

jobs:
  filter:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: pip install -q -r requirements.txt

      - name: Download latest mihomo
        if: ${{ github.event_name == 'schedule' || github.event.inputs.mode != 'fast' }}
        run: |
          MIHOMO_VERSION=$(curl -sL https://api.github.com/repos/MetaCubeX/mihomo/releases/latest | grep '"tag_name"' | sed -E 's/.*"([^"]+)".*/\1/')
          echo "Downloading mihomo ${MIHOMO_VERSION}..."
          curl -sL -o mihomo.gz "https://github.com/MetaCubeX/mihomo/releases/download/${MIHOMO_VERSION}/mihomo-linux-amd64-${MIHOMO_VERSION}.gz"
          gunzip mihomo.gz
          chmod +x mihomo
          sudo mv mihomo /usr/local/bin/mihomo
          mihomo -v

      - name: Fetch subscriptions list and download
        env:
          WORKER_URL: ${{ secrets.WORKER_URL }}
          WORKER_AUTH_TOKEN: ${{ secrets.WORKER_AUTH_TOKEN }}
        run: |
          mkdir -p /tmp/subs

          echo "从 Worker 获取订阅列表并直接拉取内容..."
          # 获取列表使用浏览器 UA 避免被 Cloudflare 拦截 (1010)
          LIST_JSON=$(curl -sf -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36" "${WORKER_URL}/api/subs?token=${WORKER_AUTH_TOKEN}")
          if [ $? -ne 0 ]; then
            echo "::error::获取订阅列表失败，可能是被 Cloudflare 拦截"
            exit 1
          fi

          # 使用 Python 批量下载内容
          echo "$LIST_JSON" | python3 -c "
          import json, sys, urllib.request, ssl, os
          
          # 创建忽略 SSL 验证的上下文
          ctx = ssl.create_default_context()
          ctx.check_hostname = False
          ctx.verify_mode = ssl.CERT_NONE

          try:
              data = json.load(sys.stdin)
          except:
              print('::error::无效的 JSON 响应')
              sys.exit(1)

          if not data.get('ok'):
              print('::error::Worker 返回错误')
              sys.exit(1)

          subs = data.get('data', [])
          ua = os.environ.get('GLOBAL_UA', 'clash-verge/2.4.5')
          count = 0
          for i, sub in enumerate(subs):
              name = sub.get('name', f'sub_{i}')
              url = sub.get('url')
              if not url: continue
              
              print(f'正在下载: {name} ...')
              try:
                  req = urllib.request.Request(url, headers={'User-Agent': ua})
                  with urllib.request.urlopen(req, context=ctx, timeout=20) as response:
                      content = response.read().decode('utf-8', errors='ignore')
                      if content.strip():
                          with open(f'/tmp/subs/sub_{i}.yaml', 'w') as f:
                              f.write(content)
                          count += 1
              except Exception as e:
                  print(f'::warning::下载 {name} 失败: {e}')

          print(f'成功下载 {count} 个订阅')
          if count == 0:
              print('::error::没有成功获取任何订阅内容')
              sys.exit(1)
          "

      - name: Run filter
        env:
          MODE: ${{ github.event.inputs.mode || 'precise' }}
        run: |
          ARGS=""
          for f in /tmp/subs/sub_*.yaml; do
            [ -f "$f" ] && ARGS="$ARGS -f $f"
          done
          if [ "$MODE" != "fast" ]; then
            ARGS="$ARGS --test"
          fi
          python3 main.py $ARGS

      - name: Show report
        run: cat output/filter_report.md

      - name: Upload results to Worker
        env:
          WORKER_URL: ${{ secrets.WORKER_URL }}
          WORKER_AUTH_TOKEN: ${{ secrets.WORKER_AUTH_TOKEN }}
        run: |
          echo "正在上传筛选结果和报告到 Worker..."
          
          python3 -c "
          import json, urllib.request, os, sys

          def push(path, api_path, key):
              if not os.path.exists(path):
                  print(f'文件不存在: {path}')
                  return
              
              url = os.environ['WORKER_URL'].rstrip('/') + api_path + '?token=' + os.environ['WORKER_AUTH_TOKEN']
              print(f'推送 {path} 到 {api_path} ...')
              
              try:
                  with open(path, 'r', encoding='utf-8') as f:
                      content = f.read()
                  
                  payload = json.dumps({key: content}).encode('utf-8')
                  req = urllib.request.Request(
                      url, 
                      data=payload, 
                      headers={
                          'Content-Type': 'application/json',
                          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                      }, 
                      method='POST'
                  )
                  
                  with urllib.request.urlopen(req, timeout=30) as resp:
                      result = json.loads(resp.read().decode())
                      if result.get('ok'):
                          print(f'成功推送 {path}')
                      else:
                          err = result.get('error', '未知错误')
                          print(f'推送失败: {err}')
              except urllib.error.HTTPError as e:
                  body = e.read().decode()
                  print(f'请求异常 ({path}): {e} - 响应内容: {body}')
              except Exception as e:
                  print(f'请求异常 ({path}): {e}')

          # 1. 上传配置
          push('output/filtered_config.yaml', '/api/filter/config', 'yaml')
          
          # 2. 上传报告
          push('output/filter_report.md', '/api/filter/report', 'report')
          "
